/*--------------------------------------------------------------------------*/
/* Copyright 2023 NXP                                                       */
/*                                                                          */
/* NXP Confidential. This software is owned or controlled by NXP and may    */
/* only be used strictly in accordance with the applicable license terms.   */
/* By expressly accepting such terms or by downloading, installing,         */
/* activating and/or otherwise using the software, you are agreeing that    */
/* you have read, and that you agree to comply with and are bound by, such  */
/* license terms. If you do not agree to be bound by the applicable license */
/* terms, then you may not retain, install, activate or otherwise use the   */
/* software.                                                                */
/*--------------------------------------------------------------------------*/

/**
 * @file  mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example.c
 * @brief Example for the mcuxClRandomModes component
 *
 * @example mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example.c
 * @brief   Example for the mcuxClRandomModes component
 */

#include <mcuxClRandom.h>
#include <mcuxClRandomModes.h>
#include <mcuxClSession.h>
#include <mcuxCsslFlowProtection.h>
#include <mcuxClCore_FunctionIdentifiers.h> // Code flow protection
#include <mcuxClExample_Session_Helper.h>
#include <mcuxClCore_Examples.h>
#include <mcuxClEls.h> // Interface to the entire mcuxClEls component
#include <mcuxClExample_ELS_Helper.h>

#define CEILING(x,y)  ( ((x) + ((y)-1U)) / (y) )
#define DRBG_BUFFER1_SIZE (MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3-29u)
#define DRBG_BUFFER2_SIZE (MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3*2u)
#define DRBG_BUFFER3_SIZE (MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3+4u)


static const uint32_t entropyInputInit[CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_INIT_ENTROPY_SIZE, sizeof(uint32_t))] =
{
    // Entropy for init (last byte is not used, because initSize is 71 bytes)
    0xd871e6c9u, 0x45a82e7du, 0x26ef0940u, 0x80cb91b8u, 0x2e211226u, 0xd6416349u, 0x1b227780u, 0x14ef2f2eu, 
    0xfdc37262u, 0x2db280b8u, 0x4808837au, 0xb6d5680bu, 0x54a9ec86u, 0x699cfaa2u, 0xdb9134d9u, 0xa3bcd0c9u, 
    0x7e62a5dau, 0x00e08521u
};

static const uint32_t entropyInputReseed1_2[CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_RESEED_ENTROPY_SIZE, sizeof(uint32_t))
                                    + CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_RESEED_ENTROPY_SIZE, sizeof(uint32_t))] =
{
    // Entropy for first reseed (last byte is not used in first reseed, because reseedsize is 55 bytes)
    0xe19793c3u, 0x336d3bedu, 0x32ea9ac4u, 0x56c2b89fu, 0xe90cd270u, 0x0146b0a4u, 0xb19a334au, 0x805f2e78u, 
    0x1ae376eau, 0x46683dedu, 0x186c9b7bu, 0x682e6ea8u, 0x836d643du, 0x1f7356a2u,
    // Entropy for second reseed (last byte from first reseed is used, two last bytes from this reseed not used, because reseedsize is 55 bytes)
    0xc437f850u, 0x8238cd74u, 0x9812eb32u, 0x9859fc43u, 0x528daf05u, 0x3c4c0016u, 0x18c5bb22u, 0xd0703bf9u, 
    0xa5fd78e5u, 0x888a413au, 0xc818c52eu, 0xee4058ebu, 0xe62274e3u, 0x5f9ffe64u
};

static const uint32_t entropyInputReseed3[CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_RESEED_ENTROPY_SIZE, sizeof(uint32_t))] =
{
    0xbaf1c281u, 0xfd97e2d2u, 0x2d67aeacu, 0x7fac7f76u, 0xb8d24963u, 0x3f1217f7u, 0x7752b4c7u, 0x4b46ab80u, 
    0x0bdc722au, 0x76d7e3aeu, 0x18b9eb96u, 0xd6e78615u, 0xc708eb47u, 0x45ae03b9u
};

/* Reference output is generated by running this example */
static const uint8_t refOutput_drbg3[DRBG_BUFFER3_SIZE] =
{
    0x9Fu, 0xD2u, 0x84u, 0x36u, 0xF8u, 0xF9u, 0xA2u, 0xAAu,
    0x8Bu, 0x21u, 0x09u, 0x6Eu, 0x68u, 0x3Eu, 0xCFu, 0xDBu,
    0xD6u, 0x13u, 0x9Eu, 0xE2u, 0x8Du, 0x31u, 0x6Eu, 0x28u,
    0x52u, 0xD5u, 0x4Cu, 0x31u, 0xC0u, 0x2Cu, 0x19u, 0xB9u,
    0x55u, 0x01u, 0x29u, 0x8Du
};

/** Performs an example usage of the mcuxClRandom and mcuxClRandomModes components with test mode.
 * @retval true  The example code completed successfully
 * @retval false The example code failed */
bool mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example(void)
{
    /**************************************************************************/
    /* Preparation                                                            */
    /**************************************************************************/

    /** Initialize ELS, Enable the ELS **/
    if(!mcuxClExample_Els_Init(MCUXCLELS_RESET_DO_NOT_CANCEL))
    {
        return MCUXCLEXAMPLE_ERROR;
    }

    mcuxClSession_Descriptor_t sessionDesc;
    mcuxClSession_Handle_t session = &sessionDesc;
    MCUXCLEXAMPLE_ALLOCATE_AND_INITIALIZE_SESSION(session, MCUXCLRANDOMMODES_MAX_CPU_WA_BUFFER_SIZE, 0u);

    /* Allocate space for a test mode descriptor for an AES-256 CTR_DRBG PTG3. */
    uint32_t testModeDescBytes[(MCUXCLRANDOMMODES_TESTMODE_DESCRIPTOR_SIZE + sizeof(uint32_t) - 1U)/sizeof(uint32_t)];
    mcuxClRandom_ModeDescriptor_t *pTestModeDesc = (mcuxClRandom_ModeDescriptor_t *) testModeDescBytes;

    /**************************************************************************/
    /* Test mode creation and for an AES-256 CTR_DRBG PTG3 and preparation    */
    /* of known entropy input for later DRBG instantiation                    */
    /**************************************************************************/
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(cp_status, cp_token, mcuxClRandomModes_createTestFromNormalMode(
                                        pTestModeDesc,
                                        mcuxClRandomModes_Mode_CtrDrbg_AES256_PTG3,
                                        entropyInputInit
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_createTestFromNormalMode) != cp_token) || (MCUXCLRANDOM_STATUS_OK != cp_status))
    {
        return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /**************************************************************************/
    /* Test mode initialization with known entropy input                      */
    /**************************************************************************/
    uint32_t context[MCUXCLRANDOMMODES_CTR_DRBG_AES256_CONTEXT_SIZE_IN_WORDS] = {0};
    
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ri_status, init_token, mcuxClRandom_init(
                                        session,
                                        (mcuxClRandom_Context_t)context,
                                        pTestModeDesc
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_init) != init_token) || (MCUXCLRANDOM_STATUS_OK != ri_status))
    {
        return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /**************************************************************************/
    /* Generate several random byte strings and reseed the DRBG in between    */
    /* with known entropy.                                                    */
    /**************************************************************************/
    /* Buffers to store the generated random values in. */
    uint8_t drbg_buffer1[DRBG_BUFFER1_SIZE] = {0u};
    uint8_t drbg_buffer2[DRBG_BUFFER2_SIZE] = {0u};
    uint8_t drbg_buffer3[DRBG_BUFFER3_SIZE] = {0u};


    /* No reseed is needed during first generate */
    /* Generate random values of smaller amount than MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3. */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(rg1_status, generate1_token, mcuxClRandom_generate(
                                        session,
                                        drbg_buffer1,
                                        DRBG_BUFFER1_SIZE
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_generate) != generate1_token) || (MCUXCLRANDOM_STATUS_OK != rg1_status))
    {
        return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /* Update entropy input to be taken for the upcoming reseeding in generate */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ue_status1, ue_token1, mcuxClRandomModes_updateEntropyInput(pTestModeDesc, entropyInputReseed1_2));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_updateEntropyInput) != ue_token1) || (MCUXCLRANDOM_STATUS_OK != ue_status1))
    {
        return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /* Generate random values of multiple of MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3. */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(rg2_status, generate2_token, mcuxClRandom_generate(
                                        session,
                                        drbg_buffer2,
                                        DRBG_BUFFER2_SIZE
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_generate) != generate2_token) || (MCUXCLRANDOM_STATUS_OK != rg2_status))
    {
      return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /* Update entropy input to be taken for the upcoming reseeding in generate */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ue_status2, ue_token2, mcuxClRandomModes_updateEntropyInput(pTestModeDesc, entropyInputReseed3));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_updateEntropyInput) != ue_token2) || (MCUXCLRANDOM_STATUS_OK != ue_status2))
    {
        return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /* Generate random values of larger amount than but not multiple of MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3. */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(rg3_status, generate3_token, mcuxClRandom_generate(
                                        session,
                                        drbg_buffer3,
                                        DRBG_BUFFER3_SIZE
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_generate) != generate3_token) || (MCUXCLRANDOM_STATUS_OK != rg3_status))
    {
      return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /**************************************************************************/
    /* Compare the last generated random output to the expected output        */
    /**************************************************************************/
    
    bool outputIsExpected = mcuxClCore_assertEqual((const uint8_t*)drbg_buffer3, (const uint8_t*)refOutput_drbg3, DRBG_BUFFER3_SIZE);

    /* Return error if buffers are unequal */
    if(!outputIsExpected)
    {
      return MCUXCLEXAMPLE_ERROR;
    }

    /**************************************************************************/
    /* Cleanup                                                                */
    /**************************************************************************/

    /* Random uninit. */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ru_status, uninit_token, mcuxClRandom_uninit(session));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_uninit) != uninit_token) || (MCUXCLRANDOM_STATUS_OK != ru_status))
    {
      return MCUXCLEXAMPLE_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /** Destroy Session and cleanup Session **/
    if(!mcuxClExample_Session_Clean(session))
    {
        return MCUXCLEXAMPLE_ERROR;
    }

    /** Disable the ELS **/
    if(!mcuxClExample_Els_Disable())
    {
        return MCUXCLEXAMPLE_ERROR;
    }

    return MCUXCLEXAMPLE_OK;
}
